// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: users.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBusiness = `-- name: CreateBusiness :one
INSERT INTO businesses (
  contact_person_name, contact_person_email, contact_person_mobile_number,
  company_name, address, pin, city, state, country, business_type,
  gst, pan, bank_account_number, bank_name, ifsc_code, account_type, account_holder_name
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
)
RETURNING id, contact_person_name, contact_person_email, contact_person_mobile_number, company_name, address, pin, city, state, country, business_type, gst, pan, bank_account_number, bank_name, ifsc_code, account_type, account_holder_name
`

type CreateBusinessParams struct {
	ContactPersonName         string `json:"contact_person_name"`
	ContactPersonEmail        string `json:"contact_person_email"`
	ContactPersonMobileNumber string `json:"contact_person_mobile_number"`
	CompanyName               string `json:"company_name"`
	Address                   string `json:"address"`
	Pin                       int32  `json:"pin"`
	City                      string `json:"city"`
	State                     string `json:"state"`
	Country                   string `json:"country"`
	BusinessType              string `json:"business_type"`
	Gst                       string `json:"gst"`
	Pan                       string `json:"pan"`
	BankAccountNumber         string `json:"bank_account_number"`
	BankName                  string `json:"bank_name"`
	IfscCode                  string `json:"ifsc_code"`
	AccountType               string `json:"account_type"`
	AccountHolderName         string `json:"account_holder_name"`
}

func (q *Queries) CreateBusiness(ctx context.Context, arg CreateBusinessParams) (Business, error) {
	row := q.db.QueryRow(ctx, createBusiness,
		arg.ContactPersonName,
		arg.ContactPersonEmail,
		arg.ContactPersonMobileNumber,
		arg.CompanyName,
		arg.Address,
		arg.Pin,
		arg.City,
		arg.State,
		arg.Country,
		arg.BusinessType,
		arg.Gst,
		arg.Pan,
		arg.BankAccountNumber,
		arg.BankName,
		arg.IfscCode,
		arg.AccountType,
		arg.AccountHolderName,
	)
	var i Business
	err := row.Scan(
		&i.ID,
		&i.ContactPersonName,
		&i.ContactPersonEmail,
		&i.ContactPersonMobileNumber,
		&i.CompanyName,
		&i.Address,
		&i.Pin,
		&i.City,
		&i.State,
		&i.Country,
		&i.BusinessType,
		&i.Gst,
		&i.Pan,
		&i.BankAccountNumber,
		&i.BankName,
		&i.IfscCode,
		&i.AccountType,
		&i.AccountHolderName,
	)
	return i, err
}

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories (name, description, business_id)
VALUES ($1, $2, $3)
RETURNING id, name, description, business_id
`

type CreateCategoryParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	BusinessID  int32       `json:"business_id"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (Category, error) {
	row := q.db.QueryRow(ctx, createCategory, arg.Name, arg.Description, arg.BusinessID)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BusinessID,
	)
	return i, err
}

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customers (phone_number, name, whatsapp, email, address, outlet_id, business_id)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, phone_number, name, whatsapp, email, address, outlet_id, business_id
`

type CreateCustomerParams struct {
	PhoneNumber string      `json:"phone_number"`
	Name        string      `json:"name"`
	Whatsapp    pgtype.Bool `json:"whatsapp"`
	Email       pgtype.Text `json:"email"`
	Address     pgtype.Text `json:"address"`
	OutletID    int32       `json:"outlet_id"`
	BusinessID  int32       `json:"business_id"`
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, createCustomer,
		arg.PhoneNumber,
		arg.Name,
		arg.Whatsapp,
		arg.Email,
		arg.Address,
		arg.OutletID,
		arg.BusinessID,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.PhoneNumber,
		&i.Name,
		&i.Whatsapp,
		&i.Email,
		&i.Address,
		&i.OutletID,
		&i.BusinessID,
	)
	return i, err
}

const createMenuItem = `-- name: CreateMenuItem :one
INSERT INTO menu_items (
    category_id, name, description, price, is_vegetarian, spice_level,
    is_available, business_id, code, tax_percentage, size_type, variation,
    customizable, image
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
) RETURNING id, category_id, name, description, price, is_vegetarian, spice_level, is_available, business_id, is_deleted, code, customizable, image, size_type, tax_percentage, variation
`

type CreateMenuItemParams struct {
	CategoryID    int32          `json:"category_id"`
	Name          string         `json:"name"`
	Description   pgtype.Text    `json:"description"`
	Price         pgtype.Numeric `json:"price"`
	IsVegetarian  bool           `json:"is_vegetarian"`
	SpiceLevel    NullSpiceLevel `json:"spice_level"`
	IsAvailable   bool           `json:"is_available"`
	BusinessID    int32          `json:"business_id"`
	Code          string         `json:"code"`
	TaxPercentage int32          `json:"tax_percentage"`
	SizeType      SizeType       `json:"size_type"`
	Variation     []byte         `json:"variation"`
	Customizable  bool           `json:"customizable"`
	Image         pgtype.Text    `json:"image"`
}

func (q *Queries) CreateMenuItem(ctx context.Context, arg CreateMenuItemParams) (MenuItem, error) {
	row := q.db.QueryRow(ctx, createMenuItem,
		arg.CategoryID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.IsVegetarian,
		arg.SpiceLevel,
		arg.IsAvailable,
		arg.BusinessID,
		arg.Code,
		arg.TaxPercentage,
		arg.SizeType,
		arg.Variation,
		arg.Customizable,
		arg.Image,
	)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.IsVegetarian,
		&i.SpiceLevel,
		&i.IsAvailable,
		&i.BusinessID,
		&i.IsDeleted,
		&i.Code,
		&i.Customizable,
		&i.Image,
		&i.SizeType,
		&i.TaxPercentage,
		&i.Variation,
	)
	return i, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
  customer_id, phone_number, name, email, address, order_id, status, gst_amount, total_amount, net_amount
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, customer_id, phone_number, name, email, address, order_id, status, gst_amount, total_amount, net_amount, created_at, updated_at
`

type CreateOrderParams struct {
	CustomerID  int32          `json:"customer_id"`
	PhoneNumber string         `json:"phone_number"`
	Name        string         `json:"name"`
	Email       pgtype.Text    `json:"email"`
	Address     pgtype.Text    `json:"address"`
	OrderID     string         `json:"order_id"`
	Status      OrderStatus    `json:"status"`
	GstAmount   pgtype.Numeric `json:"gst_amount"`
	TotalAmount pgtype.Numeric `json:"total_amount"`
	NetAmount   pgtype.Numeric `json:"net_amount"`
}

type CreateOrderRow struct {
	ID          int32            `json:"id"`
	CustomerID  int32            `json:"customer_id"`
	PhoneNumber string           `json:"phone_number"`
	Name        string           `json:"name"`
	Email       pgtype.Text      `json:"email"`
	Address     pgtype.Text      `json:"address"`
	OrderID     string           `json:"order_id"`
	Status      OrderStatus      `json:"status"`
	GstAmount   pgtype.Numeric   `json:"gst_amount"`
	TotalAmount pgtype.Numeric   `json:"total_amount"`
	NetAmount   pgtype.Numeric   `json:"net_amount"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (CreateOrderRow, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.CustomerID,
		arg.PhoneNumber,
		arg.Name,
		arg.Email,
		arg.Address,
		arg.OrderID,
		arg.Status,
		arg.GstAmount,
		arg.TotalAmount,
		arg.NetAmount,
	)
	var i CreateOrderRow
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.PhoneNumber,
		&i.Name,
		&i.Email,
		&i.Address,
		&i.OrderID,
		&i.Status,
		&i.GstAmount,
		&i.TotalAmount,
		&i.NetAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :exec
INSERT INTO order_items (
  item_code, item_description, variation, quantity, unit_price, net_price, tax_precentage, gst_amount, total_amount, order_id
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
`

type CreateOrderItemParams struct {
	ItemCode        string         `json:"item_code"`
	ItemDescription string         `json:"item_description"`
	Variation       []byte         `json:"variation"`
	Quantity        int32          `json:"quantity"`
	UnitPrice       pgtype.Numeric `json:"unit_price"`
	NetPrice        pgtype.Numeric `json:"net_price"`
	TaxPrecentage   int32          `json:"tax_precentage"`
	GstAmount       pgtype.Numeric `json:"gst_amount"`
	TotalAmount     pgtype.Numeric `json:"total_amount"`
	OrderID         int32          `json:"order_id"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) error {
	_, err := q.db.Exec(ctx, createOrderItem,
		arg.ItemCode,
		arg.ItemDescription,
		arg.Variation,
		arg.Quantity,
		arg.UnitPrice,
		arg.NetPrice,
		arg.TaxPrecentage,
		arg.GstAmount,
		arg.TotalAmount,
		arg.OrderID,
	)
	return err
}

const createOutlet = `-- name: CreateOutlet :one
INSERT INTO outlets (
  outlet_name, outlet_address, outlet_pin, outlet_city, outlet_state,
  outlet_country, business_id
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, outlet_name, outlet_address, outlet_pin, outlet_city, outlet_state, outlet_country, business_id
`

type CreateOutletParams struct {
	OutletName    string `json:"outlet_name"`
	OutletAddress string `json:"outlet_address"`
	OutletPin     int32  `json:"outlet_pin"`
	OutletCity    string `json:"outlet_city"`
	OutletState   string `json:"outlet_state"`
	OutletCountry string `json:"outlet_country"`
	BusinessID    int32  `json:"business_id"`
}

func (q *Queries) CreateOutlet(ctx context.Context, arg CreateOutletParams) (Outlet, error) {
	row := q.db.QueryRow(ctx, createOutlet,
		arg.OutletName,
		arg.OutletAddress,
		arg.OutletPin,
		arg.OutletCity,
		arg.OutletState,
		arg.OutletCountry,
		arg.BusinessID,
	)
	var i Outlet
	err := row.Scan(
		&i.ID,
		&i.OutletName,
		&i.OutletAddress,
		&i.OutletPin,
		&i.OutletCity,
		&i.OutletState,
		&i.OutletCountry,
		&i.BusinessID,
	)
	return i, err
}

const createOutletMenuItem = `-- name: CreateOutletMenuItem :one
INSERT INTO outlet_menu_items (
    menu_item_id, outlet_id, price, is_available, created_by
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, menu_item_id, outlet_id, price, is_available, created_by
`

type CreateOutletMenuItemParams struct {
	MenuItemID  int32          `json:"menu_item_id"`
	OutletID    int32          `json:"outlet_id"`
	Price       pgtype.Numeric `json:"price"`
	IsAvailable bool           `json:"is_available"`
	CreatedBy   int32          `json:"created_by"`
}

func (q *Queries) CreateOutletMenuItem(ctx context.Context, arg CreateOutletMenuItemParams) (OutletMenuItem, error) {
	row := q.db.QueryRow(ctx, createOutletMenuItem,
		arg.MenuItemID,
		arg.OutletID,
		arg.Price,
		arg.IsAvailable,
		arg.CreatedBy,
	)
	var i OutletMenuItem
	err := row.Scan(
		&i.ID,
		&i.MenuItemID,
		&i.OutletID,
		&i.Price,
		&i.IsAvailable,
		&i.CreatedBy,
	)
	return i, err
}

const createOutletWithUserAssociation = `-- name: CreateOutletWithUserAssociation :one
WITH new_outlet AS (
    INSERT INTO outlets (
        outlet_name,
        outlet_address,
        outlet_pin,
        outlet_city,
        outlet_state,
        outlet_country,
        business_id
    ) VALUES (
        $1, $2, $3, $4, $5, $6, $7
    ) RETURNING id, outlet_name, outlet_address, outlet_pin, outlet_city, outlet_state, outlet_country, business_id
), new_user_outlet AS (
    INSERT INTO user_outlets (
        user_id,
        business_id,
        outlet_id
    ) VALUES (
        $8,
        (SELECT business_id FROM new_outlet),
        (SELECT id FROM new_outlet)
    ) RETURNING id, user_id, business_id, outlet_id
)
SELECT 
    o.id,
    o.outlet_name,
    o.outlet_address,
    o.outlet_pin,
    o.outlet_city,
    o.outlet_state,
    o.outlet_country,
    o.business_id,
    uo.id AS user_outlet_id
FROM new_outlet o
JOIN new_user_outlet uo ON o.id = uo.outlet_id
`

type CreateOutletWithUserAssociationParams struct {
	OutletName    string `json:"outlet_name"`
	OutletAddress string `json:"outlet_address"`
	OutletPin     int32  `json:"outlet_pin"`
	OutletCity    string `json:"outlet_city"`
	OutletState   string `json:"outlet_state"`
	OutletCountry string `json:"outlet_country"`
	BusinessID    int32  `json:"business_id"`
	UserID        int32  `json:"user_id"`
}

type CreateOutletWithUserAssociationRow struct {
	ID            int32  `json:"id"`
	OutletName    string `json:"outlet_name"`
	OutletAddress string `json:"outlet_address"`
	OutletPin     int32  `json:"outlet_pin"`
	OutletCity    string `json:"outlet_city"`
	OutletState   string `json:"outlet_state"`
	OutletCountry string `json:"outlet_country"`
	BusinessID    int32  `json:"business_id"`
	UserOutletID  int32  `json:"user_outlet_id"`
}

func (q *Queries) CreateOutletWithUserAssociation(ctx context.Context, arg CreateOutletWithUserAssociationParams) (CreateOutletWithUserAssociationRow, error) {
	row := q.db.QueryRow(ctx, createOutletWithUserAssociation,
		arg.OutletName,
		arg.OutletAddress,
		arg.OutletPin,
		arg.OutletCity,
		arg.OutletState,
		arg.OutletCountry,
		arg.BusinessID,
		arg.UserID,
	)
	var i CreateOutletWithUserAssociationRow
	err := row.Scan(
		&i.ID,
		&i.OutletName,
		&i.OutletAddress,
		&i.OutletPin,
		&i.OutletCity,
		&i.OutletState,
		&i.OutletCountry,
		&i.BusinessID,
		&i.UserOutletID,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  username, password, email, name, mobile_number, user_type, business_id, outlet_id
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id
`

type CreateUserParams struct {
	Username     string      `json:"username"`
	Password     string      `json:"password"`
	Email        string      `json:"email"`
	Name         string      `json:"name"`
	MobileNumber string      `json:"mobile_number"`
	UserType     UserType    `json:"user_type"`
	BusinessID   int32       `json:"business_id"`
	OutletID     pgtype.Int4 `json:"outlet_id"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int32, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Username,
		arg.Password,
		arg.Email,
		arg.Name,
		arg.MobileNumber,
		arg.UserType,
		arg.BusinessID,
		arg.OutletID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createUserOutlet = `-- name: CreateUserOutlet :one
INSERT INTO user_outlets (
  user_id, business_id, outlet_id
) VALUES (
  $1, $2, $3
)
RETURNING id, user_id, business_id, outlet_id
`

type CreateUserOutletParams struct {
	UserID     int32  `json:"user_id"`
	BusinessID string `json:"business_id"`
	OutletID   int32  `json:"outlet_id"`
}

func (q *Queries) CreateUserOutlet(ctx context.Context, arg CreateUserOutletParams) (UserOutlet, error) {
	row := q.db.QueryRow(ctx, createUserOutlet, arg.UserID, arg.BusinessID, arg.OutletID)
	var i UserOutlet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BusinessID,
		&i.OutletID,
	)
	return i, err
}

const createUserSession = `-- name: CreateUserSession :one
INSERT INTO user_sessions (
  user_id, access_token, refresh_token, expire_at
) VALUES (
  $1, $2, $3, $4
)
RETURNING id, user_id, access_token, refresh_token, expire_at, created_at
`

type CreateUserSessionParams struct {
	UserID       int32            `json:"user_id"`
	AccessToken  string           `json:"access_token"`
	RefreshToken string           `json:"refresh_token"`
	ExpireAt     pgtype.Timestamp `json:"expire_at"`
}

func (q *Queries) CreateUserSession(ctx context.Context, arg CreateUserSessionParams) (UserSession, error) {
	row := q.db.QueryRow(ctx, createUserSession,
		arg.UserID,
		arg.AccessToken,
		arg.RefreshToken,
		arg.ExpireAt,
	)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.ExpireAt,
		&i.CreatedAt,
	)
	return i, err
}

const createUserWithBusiness = `-- name: CreateUserWithBusiness :one
WITH inserted_business AS (
    INSERT INTO businesses (
        contact_person_name, contact_person_email, contact_person_mobile_number,
        company_name, address, pin, city, state, country, business_type,
        gst, pan, bank_account_number, bank_name, ifsc_code, account_type, account_holder_name
    ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
    ) RETURNING id
)
INSERT INTO users (
    username, password, email, name, mobile_number, user_type, business_id
) VALUES (
    $18, $19, $20, $21, $22, $23, 
    (SELECT id FROM inserted_business)
) RETURNING id, username, email, name, mobile_number, user_type, business_id
`

type CreateUserWithBusinessParams struct {
	ContactPersonName         string   `json:"contact_person_name"`
	ContactPersonEmail        string   `json:"contact_person_email"`
	ContactPersonMobileNumber string   `json:"contact_person_mobile_number"`
	CompanyName               string   `json:"company_name"`
	Address                   string   `json:"address"`
	Pin                       int32    `json:"pin"`
	City                      string   `json:"city"`
	State                     string   `json:"state"`
	Country                   string   `json:"country"`
	BusinessType              string   `json:"business_type"`
	Gst                       string   `json:"gst"`
	Pan                       string   `json:"pan"`
	BankAccountNumber         string   `json:"bank_account_number"`
	BankName                  string   `json:"bank_name"`
	IfscCode                  string   `json:"ifsc_code"`
	AccountType               string   `json:"account_type"`
	AccountHolderName         string   `json:"account_holder_name"`
	Username                  string   `json:"username"`
	Password                  string   `json:"password"`
	Email                     string   `json:"email"`
	Name                      string   `json:"name"`
	MobileNumber              string   `json:"mobile_number"`
	UserType                  UserType `json:"user_type"`
}

type CreateUserWithBusinessRow struct {
	ID           int32    `json:"id"`
	Username     string   `json:"username"`
	Email        string   `json:"email"`
	Name         string   `json:"name"`
	MobileNumber string   `json:"mobile_number"`
	UserType     UserType `json:"user_type"`
	BusinessID   int32    `json:"business_id"`
}

func (q *Queries) CreateUserWithBusiness(ctx context.Context, arg CreateUserWithBusinessParams) (CreateUserWithBusinessRow, error) {
	row := q.db.QueryRow(ctx, createUserWithBusiness,
		arg.ContactPersonName,
		arg.ContactPersonEmail,
		arg.ContactPersonMobileNumber,
		arg.CompanyName,
		arg.Address,
		arg.Pin,
		arg.City,
		arg.State,
		arg.Country,
		arg.BusinessType,
		arg.Gst,
		arg.Pan,
		arg.BankAccountNumber,
		arg.BankName,
		arg.IfscCode,
		arg.AccountType,
		arg.AccountHolderName,
		arg.Username,
		arg.Password,
		arg.Email,
		arg.Name,
		arg.MobileNumber,
		arg.UserType,
	)
	var i CreateUserWithBusinessRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Name,
		&i.MobileNumber,
		&i.UserType,
		&i.BusinessID,
	)
	return i, err
}

const createUserWithBusinessAndOutlets = `-- name: CreateUserWithBusinessAndOutlets :one
   WITH inserted_business AS (
    INSERT INTO businesses (
        contact_person_name, contact_person_email, contact_person_mobile_number,
        company_name, address, pin, city, state, country, business_type,
        gst, pan, bank_account_number, bank_name, ifsc_code, account_type, account_holder_name
    ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
    ) RETURNING id
), inserted_outlet AS (
    INSERT INTO outlets (
        outlet_name, outlet_address, outlet_pin, outlet_city, outlet_state, outlet_country, business_id
    ) VALUES (
        $18, $19, $20, $21, $22, $23, (SELECT id FROM inserted_business)
    ) RETURNING id
)
INSERT INTO users (
    username, password, email, name, mobile_number, user_type, business_id, outlet_id
) VALUES (
    $24, $25, $26, $27, $28, $29::UserType, 
    (SELECT id FROM inserted_business), 
    (SELECT id FROM inserted_outlet)
) RETURNING id, username, email, name, mobile_number, user_type, business_id, outlet_id
`

type CreateUserWithBusinessAndOutletsParams struct {
	ContactPersonName         string      `json:"contact_person_name"`
	ContactPersonEmail        string      `json:"contact_person_email"`
	ContactPersonMobileNumber string      `json:"contact_person_mobile_number"`
	CompanyName               string      `json:"company_name"`
	Address                   string      `json:"address"`
	Pin                       int32       `json:"pin"`
	City                      string      `json:"city"`
	State                     string      `json:"state"`
	Country                   string      `json:"country"`
	BusinessType              string      `json:"business_type"`
	Gst                       string      `json:"gst"`
	Pan                       string      `json:"pan"`
	BankAccountNumber         string      `json:"bank_account_number"`
	BankName                  string      `json:"bank_name"`
	IfscCode                  string      `json:"ifsc_code"`
	AccountType               string      `json:"account_type"`
	AccountHolderName         string      `json:"account_holder_name"`
	OutletName                string      `json:"outlet_name"`
	OutletAddress             string      `json:"outlet_address"`
	OutletPin                 int32       `json:"outlet_pin"`
	OutletCity                string      `json:"outlet_city"`
	OutletState               string      `json:"outlet_state"`
	OutletCountry             string      `json:"outlet_country"`
	Username                  string      `json:"username"`
	Password                  string      `json:"password"`
	Email                     string      `json:"email"`
	Name                      string      `json:"name"`
	MobileNumber              string      `json:"mobile_number"`
	Column29                  interface{} `json:"column_29"`
}

type CreateUserWithBusinessAndOutletsRow struct {
	ID           int32       `json:"id"`
	Username     string      `json:"username"`
	Email        string      `json:"email"`
	Name         string      `json:"name"`
	MobileNumber string      `json:"mobile_number"`
	UserType     UserType    `json:"user_type"`
	BusinessID   int32       `json:"business_id"`
	OutletID     pgtype.Int4 `json:"outlet_id"`
}

func (q *Queries) CreateUserWithBusinessAndOutlets(ctx context.Context, arg CreateUserWithBusinessAndOutletsParams) (CreateUserWithBusinessAndOutletsRow, error) {
	row := q.db.QueryRow(ctx, createUserWithBusinessAndOutlets,
		arg.ContactPersonName,
		arg.ContactPersonEmail,
		arg.ContactPersonMobileNumber,
		arg.CompanyName,
		arg.Address,
		arg.Pin,
		arg.City,
		arg.State,
		arg.Country,
		arg.BusinessType,
		arg.Gst,
		arg.Pan,
		arg.BankAccountNumber,
		arg.BankName,
		arg.IfscCode,
		arg.AccountType,
		arg.AccountHolderName,
		arg.OutletName,
		arg.OutletAddress,
		arg.OutletPin,
		arg.OutletCity,
		arg.OutletState,
		arg.OutletCountry,
		arg.Username,
		arg.Password,
		arg.Email,
		arg.Name,
		arg.MobileNumber,
		arg.Column29,
	)
	var i CreateUserWithBusinessAndOutletsRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Name,
		&i.MobileNumber,
		&i.UserType,
		&i.BusinessID,
		&i.OutletID,
	)
	return i, err
}

const deleteBusiness = `-- name: DeleteBusiness :exec
DELETE FROM businesses
WHERE id = $1
`

func (q *Queries) DeleteBusiness(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteBusiness, id)
	return err
}

const deleteCustomer = `-- name: DeleteCustomer :exec
DELETE FROM customers WHERE id = $1
`

func (q *Queries) DeleteCustomer(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteCustomer, id)
	return err
}

const deleteOutlet = `-- name: DeleteOutlet :exec
DELETE FROM outlets
WHERE id = $1
`

func (q *Queries) DeleteOutlet(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteOutlet, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const deleteUserOutlet = `-- name: DeleteUserOutlet :exec
DELETE FROM user_outlets
WHERE id = $1
`

func (q *Queries) DeleteUserOutlet(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteUserOutlet, id)
	return err
}

const deleteUserSession = `-- name: DeleteUserSession :exec
DELETE FROM user_sessions
WHERE user_id = $1
`

func (q *Queries) DeleteUserSession(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteUserSession, userID)
	return err
}

const deleteUserSessions = `-- name: DeleteUserSessions :exec
DELETE FROM user_sessions
WHERE user_id = $1
`

func (q *Queries) DeleteUserSessions(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteUserSessions, userID)
	return err
}

const getAllCategories = `-- name: GetAllCategories :many
SELECT id, name, description, business_id FROM categories
WHERE business_id = $1
ORDER BY name
`

func (q *Queries) GetAllCategories(ctx context.Context, businessID int32) ([]Category, error) {
	rows, err := q.db.Query(ctx, getAllCategories, businessID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.BusinessID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllMenuItemsByBusinessID = `-- name: GetAllMenuItemsByBusinessID :many
SELECT 
    mi.id,
    mi.category_id,
    mi.name,
    mi.description,
    mi.price,
    mi.is_vegetarian,
    mi.spice_level,
    mi.is_available,
    mi.is_deleted,
    c.name AS category_name
FROM 
    menu_items mi
LEFT JOIN 
    categories c ON mi.category_id = c.id
WHERE 
    mi.business_id = $1 AND mi.is_deleted = false
ORDER BY 
    mi.name
`

type GetAllMenuItemsByBusinessIDRow struct {
	ID           int32          `json:"id"`
	CategoryID   int32          `json:"category_id"`
	Name         string         `json:"name"`
	Description  pgtype.Text    `json:"description"`
	Price        pgtype.Numeric `json:"price"`
	IsVegetarian bool           `json:"is_vegetarian"`
	SpiceLevel   NullSpiceLevel `json:"spice_level"`
	IsAvailable  bool           `json:"is_available"`
	IsDeleted    bool           `json:"is_deleted"`
	CategoryName pgtype.Text    `json:"category_name"`
}

func (q *Queries) GetAllMenuItemsByBusinessID(ctx context.Context, businessID int32) ([]GetAllMenuItemsByBusinessIDRow, error) {
	rows, err := q.db.Query(ctx, getAllMenuItemsByBusinessID, businessID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllMenuItemsByBusinessIDRow
	for rows.Next() {
		var i GetAllMenuItemsByBusinessIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.IsVegetarian,
			&i.SpiceLevel,
			&i.IsAvailable,
			&i.IsDeleted,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBusinessByID = `-- name: GetBusinessByID :one
SELECT id, contact_person_name, contact_person_email, contact_person_mobile_number, company_name, address, pin, city, state, country, business_type, gst, pan, bank_account_number, bank_name, ifsc_code, account_type, account_holder_name FROM businesses
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetBusinessByID(ctx context.Context, id int32) (Business, error) {
	row := q.db.QueryRow(ctx, getBusinessByID, id)
	var i Business
	err := row.Scan(
		&i.ID,
		&i.ContactPersonName,
		&i.ContactPersonEmail,
		&i.ContactPersonMobileNumber,
		&i.CompanyName,
		&i.Address,
		&i.Pin,
		&i.City,
		&i.State,
		&i.Country,
		&i.BusinessType,
		&i.Gst,
		&i.Pan,
		&i.BankAccountNumber,
		&i.BankName,
		&i.IfscCode,
		&i.AccountType,
		&i.AccountHolderName,
	)
	return i, err
}

const getCustomerByID = `-- name: GetCustomerByID :one
SELECT id, phone_number, name, whatsapp, email, address, outlet_id, business_id FROM customers WHERE id = $1
`

func (q *Queries) GetCustomerByID(ctx context.Context, id int32) (Customer, error) {
	row := q.db.QueryRow(ctx, getCustomerByID, id)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.PhoneNumber,
		&i.Name,
		&i.Whatsapp,
		&i.Email,
		&i.Address,
		&i.OutletID,
		&i.BusinessID,
	)
	return i, err
}

const getCustomerByPhoneNumber = `-- name: GetCustomerByPhoneNumber :one
SELECT id, phone_number, name, email, address, whatsapp
FROM customers
WHERE phone_number = $1
`

type GetCustomerByPhoneNumberRow struct {
	ID          int32       `json:"id"`
	PhoneNumber string      `json:"phone_number"`
	Name        string      `json:"name"`
	Email       pgtype.Text `json:"email"`
	Address     pgtype.Text `json:"address"`
	Whatsapp    pgtype.Bool `json:"whatsapp"`
}

func (q *Queries) GetCustomerByPhoneNumber(ctx context.Context, phoneNumber string) (GetCustomerByPhoneNumberRow, error) {
	row := q.db.QueryRow(ctx, getCustomerByPhoneNumber, phoneNumber)
	var i GetCustomerByPhoneNumberRow
	err := row.Scan(
		&i.ID,
		&i.PhoneNumber,
		&i.Name,
		&i.Email,
		&i.Address,
		&i.Whatsapp,
	)
	return i, err
}

const getCustomersByBusinessID = `-- name: GetCustomersByBusinessID :many
SELECT id, phone_number, name, whatsapp, email, address, outlet_id, business_id FROM customers WHERE business_id = $1
`

func (q *Queries) GetCustomersByBusinessID(ctx context.Context, businessID int32) ([]Customer, error) {
	rows, err := q.db.Query(ctx, getCustomersByBusinessID, businessID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.PhoneNumber,
			&i.Name,
			&i.Whatsapp,
			&i.Email,
			&i.Address,
			&i.OutletID,
			&i.BusinessID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomersByOutletId = `-- name: GetCustomersByOutletId :many
SELECT id, phone_number, name, whatsapp, email, address, outlet_id, business_id FROM customers WHERE outlet_id = $1
`

func (q *Queries) GetCustomersByOutletId(ctx context.Context, outletID int32) ([]Customer, error) {
	rows, err := q.db.Query(ctx, getCustomersByOutletId, outletID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.PhoneNumber,
			&i.Name,
			&i.Whatsapp,
			&i.Email,
			&i.Address,
			&i.OutletID,
			&i.BusinessID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestUserSession = `-- name: GetLatestUserSession :one
SELECT id, user_id, access_token, refresh_token, expire_at, created_at FROM user_sessions
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestUserSession(ctx context.Context, userID int32) (UserSession, error) {
	row := q.db.QueryRow(ctx, getLatestUserSession, userID)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.ExpireAt,
		&i.CreatedAt,
	)
	return i, err
}

const getMenuItemByCode = `-- name: GetMenuItemByCode :one
SELECT id, code, name, price, tax_percentage, is_available FROM menu_items WHERE code = $1
`

type GetMenuItemByCodeRow struct {
	ID            int32          `json:"id"`
	Code          string         `json:"code"`
	Name          string         `json:"name"`
	Price         pgtype.Numeric `json:"price"`
	TaxPercentage int32          `json:"tax_percentage"`
	IsAvailable   bool           `json:"is_available"`
}

func (q *Queries) GetMenuItemByCode(ctx context.Context, code string) (GetMenuItemByCodeRow, error) {
	row := q.db.QueryRow(ctx, getMenuItemByCode, code)
	var i GetMenuItemByCodeRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Price,
		&i.TaxPercentage,
		&i.IsAvailable,
	)
	return i, err
}

const getMenuItemsByBusinessID = `-- name: GetMenuItemsByBusinessID :many
SELECT id, category_id, name, description, price, is_vegetarian, spice_level, is_available, business_id, is_deleted, code, customizable, image, size_type, tax_percentage, variation FROM menu_items 
WHERE business_id = $1 AND is_deleted = false
ORDER BY category_id, name
`

func (q *Queries) GetMenuItemsByBusinessID(ctx context.Context, businessID int32) ([]MenuItem, error) {
	rows, err := q.db.Query(ctx, getMenuItemsByBusinessID, businessID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MenuItem
	for rows.Next() {
		var i MenuItem
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.IsVegetarian,
			&i.SpiceLevel,
			&i.IsAvailable,
			&i.BusinessID,
			&i.IsDeleted,
			&i.Code,
			&i.Customizable,
			&i.Image,
			&i.SizeType,
			&i.TaxPercentage,
			&i.Variation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOutletByID = `-- name: GetOutletByID :one
SELECT id, outlet_name, outlet_address, outlet_pin, outlet_city, outlet_state, outlet_country, business_id FROM outlets
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetOutletByID(ctx context.Context, id int32) (Outlet, error) {
	row := q.db.QueryRow(ctx, getOutletByID, id)
	var i Outlet
	err := row.Scan(
		&i.ID,
		&i.OutletName,
		&i.OutletAddress,
		&i.OutletPin,
		&i.OutletCity,
		&i.OutletState,
		&i.OutletCountry,
		&i.BusinessID,
	)
	return i, err
}

const getOutletMenuItem = `-- name: GetOutletMenuItem :one
SELECT id, menu_item_id, outlet_id, price, is_available, created_by FROM outlet_menu_items
WHERE outlet_id = $1 AND menu_item_id = $2
`

type GetOutletMenuItemParams struct {
	OutletID   int32 `json:"outlet_id"`
	MenuItemID int32 `json:"menu_item_id"`
}

func (q *Queries) GetOutletMenuItem(ctx context.Context, arg GetOutletMenuItemParams) (OutletMenuItem, error) {
	row := q.db.QueryRow(ctx, getOutletMenuItem, arg.OutletID, arg.MenuItemID)
	var i OutletMenuItem
	err := row.Scan(
		&i.ID,
		&i.MenuItemID,
		&i.OutletID,
		&i.Price,
		&i.IsAvailable,
		&i.CreatedBy,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT email, password from users where email = $1
`

type GetUserRow struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

func (q *Queries) GetUser(ctx context.Context, email string) (GetUserRow, error) {
	row := q.db.QueryRow(ctx, getUser, email)
	var i GetUserRow
	err := row.Scan(&i.Email, &i.Password)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, name, email, password, mobile_number, user_type, username, business_id, outlet_id FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.MobileNumber,
		&i.UserType,
		&i.Username,
		&i.BusinessID,
		&i.OutletID,
	)
	return i, err
}

const getUserByUsernameOrEmail = `-- name: GetUserByUsernameOrEmail :one
SELECT id, username, password, email, name, user_type, business_id
FROM users
WHERE username = $1 OR email = $1
LIMIT 1
`

type GetUserByUsernameOrEmailRow struct {
	ID         int32    `json:"id"`
	Username   string   `json:"username"`
	Password   string   `json:"password"`
	Email      string   `json:"email"`
	Name       string   `json:"name"`
	UserType   UserType `json:"user_type"`
	BusinessID int32    `json:"business_id"`
}

func (q *Queries) GetUserByUsernameOrEmail(ctx context.Context, username string) (GetUserByUsernameOrEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByUsernameOrEmail, username)
	var i GetUserByUsernameOrEmailRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.UserType,
		&i.BusinessID,
	)
	return i, err
}

const getUserOutletByID = `-- name: GetUserOutletByID :one
SELECT id, user_id, business_id, outlet_id FROM user_outlets
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserOutletByID(ctx context.Context, id int32) (UserOutlet, error) {
	row := q.db.QueryRow(ctx, getUserOutletByID, id)
	var i UserOutlet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BusinessID,
		&i.OutletID,
	)
	return i, err
}

const getUserProfile = `-- name: GetUserProfile :one
SELECT 
    u.id,
    u.name,
    u.email,
    u.mobile_number,
    u.user_type,
    u.username,
    b.id AS business_id,
    b.company_name,
    b.contact_person_name,
    b.contact_person_email,
    b.contact_person_mobile_number,
    b.address,
    b.pin,
    b.city,
    b.state,
    b.country,
    b.business_type,
    b.gst,
    b.pan
FROM 
    users u
JOIN 
    businesses b ON u.business_id = b.id
WHERE 
    u.id = $1
`

type GetUserProfileRow struct {
	ID                        int32    `json:"id"`
	Name                      string   `json:"name"`
	Email                     string   `json:"email"`
	MobileNumber              string   `json:"mobile_number"`
	UserType                  UserType `json:"user_type"`
	Username                  string   `json:"username"`
	BusinessID                int32    `json:"business_id"`
	CompanyName               string   `json:"company_name"`
	ContactPersonName         string   `json:"contact_person_name"`
	ContactPersonEmail        string   `json:"contact_person_email"`
	ContactPersonMobileNumber string   `json:"contact_person_mobile_number"`
	Address                   string   `json:"address"`
	Pin                       int32    `json:"pin"`
	City                      string   `json:"city"`
	State                     string   `json:"state"`
	Country                   string   `json:"country"`
	BusinessType              string   `json:"business_type"`
	Gst                       string   `json:"gst"`
	Pan                       string   `json:"pan"`
}

func (q *Queries) GetUserProfile(ctx context.Context, id int32) (GetUserProfileRow, error) {
	row := q.db.QueryRow(ctx, getUserProfile, id)
	var i GetUserProfileRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.MobileNumber,
		&i.UserType,
		&i.Username,
		&i.BusinessID,
		&i.CompanyName,
		&i.ContactPersonName,
		&i.ContactPersonEmail,
		&i.ContactPersonMobileNumber,
		&i.Address,
		&i.Pin,
		&i.City,
		&i.State,
		&i.Country,
		&i.BusinessType,
		&i.Gst,
		&i.Pan,
	)
	return i, err
}

const getUserSessionByRefreshToken = `-- name: GetUserSessionByRefreshToken :one
SELECT id, user_id, access_token, refresh_token, expire_at, created_at FROM user_sessions WHERE refresh_token = $1 LIMIT 1
`

func (q *Queries) GetUserSessionByRefreshToken(ctx context.Context, refreshToken string) (UserSession, error) {
	row := q.db.QueryRow(ctx, getUserSessionByRefreshToken, refreshToken)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.ExpireAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserSessionByUserID = `-- name: GetUserSessionByUserID :one
SELECT id, user_id, access_token, refresh_token, expire_at, created_at FROM user_sessions
WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetUserSessionByUserID(ctx context.Context, userID int32) (UserSession, error) {
	row := q.db.QueryRow(ctx, getUserSessionByUserID, userID)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.ExpireAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUsers = `-- name: GetUsers :many
SELECT id, name from users where 1
`

type GetUsersRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) GetUsers(ctx context.Context) ([]GetUsersRow, error) {
	rows, err := q.db.Query(ctx, getUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersRow
	for rows.Next() {
		var i GetUsersRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBusinesses = `-- name: ListBusinesses :many
SELECT id, contact_person_name, contact_person_email, contact_person_mobile_number, company_name, address, pin, city, state, country, business_type, gst, pan, bank_account_number, bank_name, ifsc_code, account_type, account_holder_name FROM businesses
ORDER BY company_name
`

func (q *Queries) ListBusinesses(ctx context.Context) ([]Business, error) {
	rows, err := q.db.Query(ctx, listBusinesses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Business
	for rows.Next() {
		var i Business
		if err := rows.Scan(
			&i.ID,
			&i.ContactPersonName,
			&i.ContactPersonEmail,
			&i.ContactPersonMobileNumber,
			&i.CompanyName,
			&i.Address,
			&i.Pin,
			&i.City,
			&i.State,
			&i.Country,
			&i.BusinessType,
			&i.Gst,
			&i.Pan,
			&i.BankAccountNumber,
			&i.BankName,
			&i.IfscCode,
			&i.AccountType,
			&i.AccountHolderName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMenuItems = `-- name: ListMenuItems :many
SELECT id, category_id, name, description, price, is_vegetarian, spice_level, is_available, business_id, is_deleted, code, customizable, image, size_type, tax_percentage, variation FROM menu_items WHERE business_id = $1 AND is_deleted = false
`

func (q *Queries) ListMenuItems(ctx context.Context, businessID int32) ([]MenuItem, error) {
	rows, err := q.db.Query(ctx, listMenuItems, businessID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MenuItem
	for rows.Next() {
		var i MenuItem
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.IsVegetarian,
			&i.SpiceLevel,
			&i.IsAvailable,
			&i.BusinessID,
			&i.IsDeleted,
			&i.Code,
			&i.Customizable,
			&i.Image,
			&i.SizeType,
			&i.TaxPercentage,
			&i.Variation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOutletMenuItems = `-- name: ListOutletMenuItems :many
SELECT 
    omi.id, 
    omi.menu_item_id, 
    omi.outlet_id, 
    omi.price, 
    omi.is_available, 
    omi.created_by, 
    mi.name as menu_item_name, 
    mi.description as menu_item_description,
    mi.is_vegetarian, 
    mi.spice_level, 
    mi.code, 
    mi.tax_percentage,
    mi.size_type, 
    mi.variation, 
    mi.customizable, 
    mi.image, 
    mi.category_id,
    c.name as category_name
FROM outlet_menu_items omi
JOIN menu_items mi ON omi.menu_item_id = mi.id
JOIN categories c ON mi.category_id = c.id
WHERE omi.outlet_id = $1
`

type ListOutletMenuItemsRow struct {
	ID                  int32          `json:"id"`
	MenuItemID          int32          `json:"menu_item_id"`
	OutletID            int32          `json:"outlet_id"`
	Price               pgtype.Numeric `json:"price"`
	IsAvailable         bool           `json:"is_available"`
	CreatedBy           int32          `json:"created_by"`
	MenuItemName        string         `json:"menu_item_name"`
	MenuItemDescription pgtype.Text    `json:"menu_item_description"`
	IsVegetarian        bool           `json:"is_vegetarian"`
	SpiceLevel          NullSpiceLevel `json:"spice_level"`
	Code                string         `json:"code"`
	TaxPercentage       int32          `json:"tax_percentage"`
	SizeType            SizeType       `json:"size_type"`
	Variation           []byte         `json:"variation"`
	Customizable        bool           `json:"customizable"`
	Image               pgtype.Text    `json:"image"`
	CategoryID          int32          `json:"category_id"`
	CategoryName        string         `json:"category_name"`
}

func (q *Queries) ListOutletMenuItems(ctx context.Context, outletID int32) ([]ListOutletMenuItemsRow, error) {
	rows, err := q.db.Query(ctx, listOutletMenuItems, outletID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOutletMenuItemsRow
	for rows.Next() {
		var i ListOutletMenuItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.MenuItemID,
			&i.OutletID,
			&i.Price,
			&i.IsAvailable,
			&i.CreatedBy,
			&i.MenuItemName,
			&i.MenuItemDescription,
			&i.IsVegetarian,
			&i.SpiceLevel,
			&i.Code,
			&i.TaxPercentage,
			&i.SizeType,
			&i.Variation,
			&i.Customizable,
			&i.Image,
			&i.CategoryID,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOutlets = `-- name: ListOutlets :many
SELECT id, outlet_name, outlet_address, outlet_pin, outlet_city, outlet_state, outlet_country, business_id FROM outlets
WHERE business_id = $1
`

func (q *Queries) ListOutlets(ctx context.Context, businessID int32) ([]Outlet, error) {
	rows, err := q.db.Query(ctx, listOutlets, businessID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Outlet
	for rows.Next() {
		var i Outlet
		if err := rows.Scan(
			&i.ID,
			&i.OutletName,
			&i.OutletAddress,
			&i.OutletPin,
			&i.OutletCity,
			&i.OutletState,
			&i.OutletCountry,
			&i.BusinessID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserOutlets = `-- name: ListUserOutlets :many
SELECT id, user_id, business_id, outlet_id FROM user_outlets
WHERE user_id = $1
`

func (q *Queries) ListUserOutlets(ctx context.Context, userID int32) ([]UserOutlet, error) {
	rows, err := q.db.Query(ctx, listUserOutlets, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserOutlet
	for rows.Next() {
		var i UserOutlet
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BusinessID,
			&i.OutletID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, name, email, password, mobile_number, user_type, username, business_id, outlet_id FROM users
ORDER BY name
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.MobileNumber,
			&i.UserType,
			&i.Username,
			&i.BusinessID,
			&i.OutletID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBusiness = `-- name: UpdateBusiness :one
UPDATE businesses
SET contact_person_name = $2, contact_person_email = $3, contact_person_mobile_number = $4,
    company_name = $5, address = $6, pin = $7, city = $8, state = $9, country = $10,
    business_type = $11, gst = $12, pan = $13, bank_account_number = $14, bank_name = $15,
    ifsc_code = $16, account_type = $17, account_holder_name = $18
WHERE id = $1
RETURNING id, contact_person_name, contact_person_email, contact_person_mobile_number, company_name, address, pin, city, state, country, business_type, gst, pan, bank_account_number, bank_name, ifsc_code, account_type, account_holder_name
`

type UpdateBusinessParams struct {
	ID                        int32  `json:"id"`
	ContactPersonName         string `json:"contact_person_name"`
	ContactPersonEmail        string `json:"contact_person_email"`
	ContactPersonMobileNumber string `json:"contact_person_mobile_number"`
	CompanyName               string `json:"company_name"`
	Address                   string `json:"address"`
	Pin                       int32  `json:"pin"`
	City                      string `json:"city"`
	State                     string `json:"state"`
	Country                   string `json:"country"`
	BusinessType              string `json:"business_type"`
	Gst                       string `json:"gst"`
	Pan                       string `json:"pan"`
	BankAccountNumber         string `json:"bank_account_number"`
	BankName                  string `json:"bank_name"`
	IfscCode                  string `json:"ifsc_code"`
	AccountType               string `json:"account_type"`
	AccountHolderName         string `json:"account_holder_name"`
}

func (q *Queries) UpdateBusiness(ctx context.Context, arg UpdateBusinessParams) (Business, error) {
	row := q.db.QueryRow(ctx, updateBusiness,
		arg.ID,
		arg.ContactPersonName,
		arg.ContactPersonEmail,
		arg.ContactPersonMobileNumber,
		arg.CompanyName,
		arg.Address,
		arg.Pin,
		arg.City,
		arg.State,
		arg.Country,
		arg.BusinessType,
		arg.Gst,
		arg.Pan,
		arg.BankAccountNumber,
		arg.BankName,
		arg.IfscCode,
		arg.AccountType,
		arg.AccountHolderName,
	)
	var i Business
	err := row.Scan(
		&i.ID,
		&i.ContactPersonName,
		&i.ContactPersonEmail,
		&i.ContactPersonMobileNumber,
		&i.CompanyName,
		&i.Address,
		&i.Pin,
		&i.City,
		&i.State,
		&i.Country,
		&i.BusinessType,
		&i.Gst,
		&i.Pan,
		&i.BankAccountNumber,
		&i.BankName,
		&i.IfscCode,
		&i.AccountType,
		&i.AccountHolderName,
	)
	return i, err
}

const updateCustomer = `-- name: UpdateCustomer :one
UPDATE customers
SET phone_number = $2, name = $3, whatsapp = $4, email = $5, address = $6, outlet_id = $7
WHERE id = $1
RETURNING id, phone_number, name, whatsapp, email, address, outlet_id, business_id
`

type UpdateCustomerParams struct {
	ID          int32       `json:"id"`
	PhoneNumber string      `json:"phone_number"`
	Name        string      `json:"name"`
	Whatsapp    pgtype.Bool `json:"whatsapp"`
	Email       pgtype.Text `json:"email"`
	Address     pgtype.Text `json:"address"`
	OutletID    int32       `json:"outlet_id"`
}

func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, updateCustomer,
		arg.ID,
		arg.PhoneNumber,
		arg.Name,
		arg.Whatsapp,
		arg.Email,
		arg.Address,
		arg.OutletID,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.PhoneNumber,
		&i.Name,
		&i.Whatsapp,
		&i.Email,
		&i.Address,
		&i.OutletID,
		&i.BusinessID,
	)
	return i, err
}

const updateMenuItem = `-- name: UpdateMenuItem :one
UPDATE menu_items
SET category_id = $2, name = $3, description = $4, price = $5,
    is_vegetarian = $6, spice_level = $7, is_available = $8,
    code = $9, tax_percentage = $10, size_type = $11, variation = $12,
    customizable = $13, image = $14
WHERE id = $1 AND is_deleted = false
RETURNING id, category_id, name, description, price, is_vegetarian, spice_level, is_available, business_id, is_deleted, code, customizable, image, size_type, tax_percentage, variation
`

type UpdateMenuItemParams struct {
	ID            int32          `json:"id"`
	CategoryID    int32          `json:"category_id"`
	Name          string         `json:"name"`
	Description   pgtype.Text    `json:"description"`
	Price         pgtype.Numeric `json:"price"`
	IsVegetarian  bool           `json:"is_vegetarian"`
	SpiceLevel    NullSpiceLevel `json:"spice_level"`
	IsAvailable   bool           `json:"is_available"`
	Code          string         `json:"code"`
	TaxPercentage int32          `json:"tax_percentage"`
	SizeType      SizeType       `json:"size_type"`
	Variation     []byte         `json:"variation"`
	Customizable  bool           `json:"customizable"`
	Image         pgtype.Text    `json:"image"`
}

func (q *Queries) UpdateMenuItem(ctx context.Context, arg UpdateMenuItemParams) (MenuItem, error) {
	row := q.db.QueryRow(ctx, updateMenuItem,
		arg.ID,
		arg.CategoryID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.IsVegetarian,
		arg.SpiceLevel,
		arg.IsAvailable,
		arg.Code,
		arg.TaxPercentage,
		arg.SizeType,
		arg.Variation,
		arg.Customizable,
		arg.Image,
	)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.IsVegetarian,
		&i.SpiceLevel,
		&i.IsAvailable,
		&i.BusinessID,
		&i.IsDeleted,
		&i.Code,
		&i.Customizable,
		&i.Image,
		&i.SizeType,
		&i.TaxPercentage,
		&i.Variation,
	)
	return i, err
}

const updateOutlet = `-- name: UpdateOutlet :one
UPDATE outlets
SET 
    outlet_name = COALESCE($2, outlet_name),
    outlet_address = COALESCE($3, outlet_address),
    outlet_pin = COALESCE($4, outlet_pin),
    outlet_city = COALESCE($5, outlet_city),
    outlet_state = COALESCE($6, outlet_state),
    outlet_country = COALESCE($7, outlet_country)
WHERE id = $1
RETURNING id, outlet_name, outlet_address, outlet_pin, outlet_city, outlet_state, outlet_country, business_id
`

type UpdateOutletParams struct {
	ID            int32  `json:"id"`
	OutletName    string `json:"outlet_name"`
	OutletAddress string `json:"outlet_address"`
	OutletPin     int32  `json:"outlet_pin"`
	OutletCity    string `json:"outlet_city"`
	OutletState   string `json:"outlet_state"`
	OutletCountry string `json:"outlet_country"`
}

func (q *Queries) UpdateOutlet(ctx context.Context, arg UpdateOutletParams) (Outlet, error) {
	row := q.db.QueryRow(ctx, updateOutlet,
		arg.ID,
		arg.OutletName,
		arg.OutletAddress,
		arg.OutletPin,
		arg.OutletCity,
		arg.OutletState,
		arg.OutletCountry,
	)
	var i Outlet
	err := row.Scan(
		&i.ID,
		&i.OutletName,
		&i.OutletAddress,
		&i.OutletPin,
		&i.OutletCity,
		&i.OutletState,
		&i.OutletCountry,
		&i.BusinessID,
	)
	return i, err
}

const updateOutletMenuItem = `-- name: UpdateOutletMenuItem :one
UPDATE outlet_menu_items
SET price = $3, is_available = $4
WHERE outlet_id = $1 AND menu_item_id = $2
RETURNING id, menu_item_id, outlet_id, price, is_available, created_by
`

type UpdateOutletMenuItemParams struct {
	OutletID    int32          `json:"outlet_id"`
	MenuItemID  int32          `json:"menu_item_id"`
	Price       pgtype.Numeric `json:"price"`
	IsAvailable bool           `json:"is_available"`
}

func (q *Queries) UpdateOutletMenuItem(ctx context.Context, arg UpdateOutletMenuItemParams) (OutletMenuItem, error) {
	row := q.db.QueryRow(ctx, updateOutletMenuItem,
		arg.OutletID,
		arg.MenuItemID,
		arg.Price,
		arg.IsAvailable,
	)
	var i OutletMenuItem
	err := row.Scan(
		&i.ID,
		&i.MenuItemID,
		&i.OutletID,
		&i.Price,
		&i.IsAvailable,
		&i.CreatedBy,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET username = $2, email = $3, name = $4, mobile_number = $5, user_type = $6, 
    business_id = COALESCE($7, business_id), outlet_id = COALESCE($8, outlet_id)
WHERE id = $1
RETURNING id, name, email, password, mobile_number, user_type, username, business_id, outlet_id
`

type UpdateUserParams struct {
	ID           int32       `json:"id"`
	Username     string      `json:"username"`
	Email        string      `json:"email"`
	Name         string      `json:"name"`
	MobileNumber string      `json:"mobile_number"`
	UserType     UserType    `json:"user_type"`
	BusinessID   int32       `json:"business_id"`
	OutletID     pgtype.Int4 `json:"outlet_id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.Username,
		arg.Email,
		arg.Name,
		arg.MobileNumber,
		arg.UserType,
		arg.BusinessID,
		arg.OutletID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.MobileNumber,
		&i.UserType,
		&i.Username,
		&i.BusinessID,
		&i.OutletID,
	)
	return i, err
}

const updateUserSession = `-- name: UpdateUserSession :one
UPDATE user_sessions
SET access_token = $2, refresh_token = $3, expire_at = $4
WHERE user_id = $1
RETURNING id, user_id, access_token, refresh_token, expire_at, created_at
`

type UpdateUserSessionParams struct {
	UserID       int32            `json:"user_id"`
	AccessToken  string           `json:"access_token"`
	RefreshToken string           `json:"refresh_token"`
	ExpireAt     pgtype.Timestamp `json:"expire_at"`
}

func (q *Queries) UpdateUserSession(ctx context.Context, arg UpdateUserSessionParams) (UserSession, error) {
	row := q.db.QueryRow(ctx, updateUserSession,
		arg.UserID,
		arg.AccessToken,
		arg.RefreshToken,
		arg.ExpireAt,
	)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.ExpireAt,
		&i.CreatedAt,
	)
	return i, err
}
